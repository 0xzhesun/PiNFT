# PiNFT

## Background
AnyCamera is a home IP camera company. They would like to explore the Web3 space by engaging with their customers using NFTs. More specifically, AnyCamera aims to incentivize customers to take interesting pictures (e.g., pets, plants, etc.) using their IP cameras by issuing NFTs for those pictures. AnyCamera would like to collaborate with you to build a proof of concept (PoC). 

*Disclaimer: This company name is fictitious. Any resemblance to real companies is purely coincidental.*

## User Scenarios
We are covering two core features in this PoC:

**Wallet Creation**: The pPoC will incorporate a feature to automatically create an Ethereum wallet for each user. 

**Photo Submission for NFT Minting**: The PoC will enable users to send their photos directly from their AnyCamera IP cameras for NFT minting. This feature will facilitate the effortless creation of NFTs from users' unique and interesting pictures.

## Pre Started
There are two ways to play with this project: smart contract only & full PoC experience. 

If you only interested in testing the smart contract, following **Smart Contract Deployment** will help you get started with [Hardhat environment](https://hardhat.org/). 

If you are interested in full PoC experience, you will need:

- Raspberry Pi 4 (OS: Bullseye) + CSI camera
- HDMI monitor
- an AWS account

In this project I'm using [Alechemy](https://www.alchemy.com/), while feel free to use whichever platform you are comfortable with. 

All the configurations are based on Sepolia testnet.

## Getting Started

### Architecture
TODO

### Smart Contract Explained

The smart contract is designed to take 4 parameters for minting action: client wallet, client signature, image hash and owner signature.
- "Client" refers to an end user, while "owner" signifies the service provider. In our case, the service provider is the AnyCamera company.
- The smart contract will verify the following:
    - Whether the owner's signature was actually signed by the owner.
    - Whether the client's signature was indeed signed by the client.
    - Whether the client has reached the maximum number of NFTs allowed in their wallet.
    
If all three conditions are met, an NFT will be minted. This process might seem somewhat redundant, but my interpretation is as follows: The owner of the smart contract (verified via the owner's signature) authorizes my smart contract to mint an NFT for a specific client (verified via the client's signature). I currently do not have an allowlisting mechanism in place, but this design leaves room for its future implementation.

### Smart Contract Deployment

1: Open the terminal and navigate to the top level directory

2: Install the required dependencies:
```
npm install
```

3: Create `.env` file under the root folder then copy and paste the following snippet:
```
API_URL = 
API_KEY = 
PRIVATE_KEY = 
```
API_URL and API_KEY will be generated by the platform you are working on and private key would be the contract owner's private key.

4: Compile the smart contract:
```
npx hardhat compile
```
5: Deploy the smart contract to testnet:
```
npx hardhat run scripts/deploy.js --network sepolia
```
To deploy on Sepolia, you need to have some Sepolia ether. Please refer to [this documentation](https://hardhat.org/tutorial/deploying-to-a-live-network) for a detailed explanation.

6: Once the contract is deployed, you will see the contract address. Now go back to the `.env` file created on step 3 and add two more variables:
```
CLIENT_PRIVATE_KEY =
CONTRACT_ADDRESS = 
``` 
Now you will be able to interact with `script/mint.js` to understand the whole flow.

### AWS Resources

We will use DynamoDB, Lamda and S3. The actual NFT mint service (NFT) lives on AWS Lambda. User will provide the encoded image, client signature and Ethereum wallet address when calling the API. Upon receiving an NFT minting request from the device, the pre-mint inspection queries Dynamo DB to check if the requested image has not been issued an NFT previously. If not, NMS generates the owner's signature, calls the smart contract, uploads the image to S3, and logs all the information to DynamoDB. 

- Make sure you are using the same region when creating resources below
- Make sure your IAM roles have permissions to access corresponding resources. 

#### DynamoDB
1. Go to AWS console and navigate to **DynamoDB**. 

2. Create a table with name **nftTransactions**. Enter **clientWalletAddress** as Partition key and **imageHash** as sort key.

#### Amazon S3
1. Go to the AWS console and naviagte to **S3**.

2. Create a bucket and give it a name. Please notice that S3 bucket name needs to be globally unique.

#### AWS Lambda
1. Go to AWS consoel and navigate to **Lambda**.

2. Follow the steps [here](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html#configuration-layers-upload) to create a Lambda layer. Please use the output node_nodules from command below as the layer content:
```
npm install ethers@5.7.0 aws-sdk
```
3. Under `lambda/index.js`, modify the S3 bucket name to match with the one you created above.

4. Copy `artifacts/contracts/PiNFT.sol/PiNFT.json` to here and zip it with `index.js`.

5. Create a Lambda function and call it **PiNFT**, adding the layer we created in step 2, and upload the zip file from step 3.

#### Raspberry Pi

Please follow the README file under `pi` folder to complete the rest of the set up.

